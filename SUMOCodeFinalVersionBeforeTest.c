#pragma config(Sensor, S3,     colorSensor,    sensorEV3_Color, modeEV3Color_Color)
#pragma config(Sensor, S4,     sonarSensor,    sensorEV3_Ultrasonic)
#pragma config(Motor,  motorB,          leftMotor, tmotorEV3_Large, PIDControl, driveLeft, encoder)
#pragma config(Motor,  motorC,          rightMotor, tmotorEV3_Large, PIDControl, driveRight, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard!!*//

// Program loop activity pseudo-bool flag (Pseudo-init())
// Flags the entire loop to activate, post-setup
int systemRunning = 0;

// Sweep flag: Activates the sweep loop
int sweepingFlag = 0;

// Reset robot flag: Activates the initial reset loop
int initialValueFlag = 1;

// To move to the side after avoiding the edge: Allows movement post-pull away from edge
int movementPostEdge = 0;

// Testing flag that shuts down all running code, if needed; Not required for program running during Sumo match
int testStop = 0;

// post-sweep reposition; An extension of the sweep "function", so that it can search without hitting the edge first
int repositionFlag = 0;

// Change this value to change distance for sonar sensor to other robot
float distanceToTarget = 15;

// Torque calculation value scalar multplier.
//float outputGearTeeth = 0; // Number of teeth on wheel-attached gear
//float inputGearTeeth = 0; // Number of teeth on motor-attached gear
//float torqueCalculationModifier = (-1 *(outputGearTeeth/inputGearTeeth)); // The multiplicity value of what to affect the natural motor force by

// A variable to multiply any value by (-1 * ratio of gears) for the torque.
// ex. ratio of gears = (Large wheel spokes/small wheel spokes) * -1) for direction
// -1 = reversal of direction

task main()
{

// Reset robot to initial values (Encoder/Motor speed)
while (initialValueFlag)
{
nMotorEncoder[leftMotor] = 0;
nMotorEncoder[rightMotor] = 0;
setMotorSpeed(leftMotor, -50);
setMotorSpeed(rightMotor, -50);

// Stops this loop from running for the rest of the program
initialValueFlag = 0;

// Activates system for main program loop
systemRunning = 1;
}


// main program loop start
while (systemRunning)
{

// Edge of ring check and rotation:
while (getColorName(colorSensor) == colorWhite) // If the robot detects a ring/border: *****Must be set to colorWhite for running*****
{ 												// If the above (colorWhite) doesn't work, aim to use reflected mode with a higher value.

// Stop wheels and reset encoders: Avoids going over edge and allowing fine control of distance
setMotorSpeed(leftMotor, 0);
setMotorSpeed(rightMotor, 0);
nMotorEncoder[leftMotor] = 0;
nMotorEncoder[rightMotor] = 0;

// Move backwards for a particular encoder distance:
int backwardsDistance = 500;
while (nMotorEncoder[rightMotor] <= backwardsDistance || nMotorEncoder[leftMotor] <= backwardsDistance)
{
motor[leftMotor] = 50;
motor[rightMotor] = 50;
}

// Reset encoders to initialize new origin:
nMotorEncoder[leftMotor] = 0;
nMotorEncoder[rightMotor] = 0;
motor[leftMotor] = 0;
motor[rightMotor] = 0;

// Rotate a particular encoder value
int rotationValue = -950;
while (nMotorEncoder[rightMotor] >= rotationValue)
{
motor[leftMotor] = 50;
motor[rightMotor] = -50;
}

// Reset encoders to initialize new origin:
nMotorEncoder[leftMotor] = 0;
nMotorEncoder[rightMotor] = 0;
motor[leftMotor] = 0;
motor[rightMotor] = 0;
sleep(1000);

// Activates system for post-edge detection/reversal loop
movementPostEdge = 1;

}

// Move out of the way to mess with their robots search function:
while (movementPostEdge)
{

// Rotates a bit
int rotationValueEdge = -300;
while (nMotorEncoder[leftMotor] >= rotationValueEdge)
{
motor[leftMotor] = -50;
motor[rightMotor] = 50;
}

// Resets encoder values
nMotorEncoder[leftMotor] = 0;
nMotorEncoder[rightMotor] = 0;
motor[leftMotor] = 0;
motor[rightMotor] = 0;


// move away from the edge
int movementDistancePostEdge = -750;
while (nMotorEncoder[rightMotor] >= movementDistancePostEdge || nMotorEncoder[leftMotor] >= movementDistancePostEdge)
{
motor[leftMotor] = -50;
motor[rightMotor] = -50;
}

// Reset motor values and encoders
motor[leftMotor] = 0;
motor[rightMotor] = 0;
nMotorEncoder[leftMotor] = 0;
nMotorEncoder[rightMotor] = 0;



// Turn on sweeping loop
sweepingFlag = 1;

// Turn off current movement loop
movementPostEdge = 0;
}

// If the robot gets close enough to the other robot, via sonar:
while (getUSDistance(sonarSensor) <= distanceToTarget)
{
motor[leftMotor] = -80;
motor[rightMotor] = -80;
}

// Sweep for other robot
while (sweepingFlag){

// Reset encoders
nMotorEncoder[leftMotor] = 0;
nMotorEncoder[rightMotor] = 0;
motor[leftMotor] = 0;
motor[rightMotor] = 0;

// Sweeps for other robot, in a circle
int sweepRotationValue = -800; // Distance
while (nMotorEncoder[leftMotor] >= sweepRotationValue)
{
motor[leftMotor] = -50;
motor[rightMotor] = 50;

// This value is declared above (distanceToTarget); Moves towards other robot
while (getUSDistance(sonarSensor) <= distanceToTarget)
{
motor[leftMotor] = -80;
motor[rightMotor] = -80;
}
}

motor[leftMotor] = 0;
motor[rightMotor] = 0;

// Turn off sweeping function
sweepingFlag = 0;

//Turns on the reposition loop
repositionFlag = 1;

}

// Post-sweep repositioning, to avoid going to the edge, but providing similar functionality
while (repositionFlag)
{
nMotorEncoder[leftMotor] = 0;
nMotorEncoder[rightMotor] = 0;
motor[leftMotor] = 0;
motor[rightMotor] = 0;

// How far the robot should move, without a
int travelDistance = -1000;

while (nMotorEncoder[rightMotor] >= travelDistance || nMotorEncoder[leftMotor] >= travelDistance)
{
motor[leftMotor] = -50;
motor[rightMotor] = -50;

// This value is declared above (distanceToTarget); Moves towards other robot
while (getUSDistance(sonarSensor) <= distanceToTarget)
{
motor[leftMotor] = -80;
motor[rightMotor] = -80;
}
}

// Turns off reposition loop
repositionFlag = 0;

// Turns on sweeping function
sweepingFlag = 1;
}


// Stop all motor movement if the test needs to be stopped
while (testStop){
nMotorEncoder[leftMotor] = 0;
nMotorEncoder[rightMotor] = 0;
motor[leftMotor] = 0;
motor[rightMotor] = 0;
}

}
}

// End of while loop main init() body